# Closed loop control
* Create a program on the 32F746GDISCOVERY as you did last week on Atmega.

## Objectives
 - Get familiar with STM32CubeF7 library
 - Implement your last week project on an other microcontroller platform

## Materials & Resources

### How to code a P controller
You basically need:
- a reference input, which represents the desired output value
- the controller output, which controls a hardware
- the output signal, which is generated by the hardware

Let's say we have the following variables:

| variable name | functionality |
|:---------|:-----|
| ```ref``` | the reference input |
| ```ctrler_out``` | the output of the controller |
| ```process_variable``` | the output signal of the hardware, which is measured by a sensor |
| ```ctrler_out_min``` | the minimum output of the controller |
| ```ctrler_out_max``` | the maximum output of the controller |
| ```P``` | the P constant |


At first you have to calculate the error from the reference input and from the sensor
value. The next step is to multiply the error with the P constant, than load the result
value to the output. In real life, the output signal has a minimal and maximal value.
We have to limit the output to these levels.

The pseudocode of a P controller would look like:
```c_cpp
err = ref - process_variable;
ctrler_out = P * err;

if (ctrler_out < ctrler_out_min)
    ctrler_out = ctrler_out_min;
else if (ctrler_out > ctrler_out_max)
    ctrler_out = ctrler_out_max;
```

### How to code a PI controller
You basically need:
- a reference input, which represents the desired output value
- the controller output, which controls a hardware
- the output signal, which is generated by the hardware

Let's say we have the following variables:

| variable name | functionality |
|:---------|:-----|
| ```ref``` | the reference input, or setpoint |
| ```ctrler_out``` | the output of the controller |
| ```process_variable``` | the output signal of the hardware, which is measured by a sensor |
| ```ctrler_out_min``` | the minimum output of the controller |
| ```ctrler_out_max``` | the maximum output of the controller |
| ```P``` | the P constant |
| ```I``` | the I constant |


At first you have to calculate the error from the reference input and from the sensor
value. The next step is to calculate the output, which consists of
- the proportional component
- the integral component.

The proportional component is the error multiplied with the P constant.
The integral component is the sum of all previous error multiplied with the I constant.

In real life, the output signal has a minimal and maximal value.
We have to limit the output to these levels.

In case of limiting, the integral part has to be decreased by the error to avoid [integral windup](https://en.wikipedia.org/wiki/Integral_windup).

The pseudocode of a PI controller would look like:
```c_cpp
err = ref - process_variable;
integral = integral + err;
ctrler_out = P * err + I * integral;

if (ctrler_out < ctrler_out_min) {
    ctrler_out = ctrler_out_min;
    integral = integral - err;
}
else if (ctrler_out > ctrler_out_max) {
    ctrler_out = ctrler_out_max;
    integral = integral - err;
}
```

## Workshop
The input reference voltage will be adjusted with a potentiometer (which is measured with the ADC), the controller output signal will be the duty cycle of the PWM signal (which adjusts the fan rotation speed).
The rotational speed need to be measured with an external AC chip.

### Tasks
- Open loop control
- Closed loop P control
- Closed loop PI control

### Wiring
- PWM signal pin: PB_4
- ADC input pin: PA_0
- Connect the LM393 chip's output pin to the PA_15 pin of the microcontroller

[LM393 datasheet](http://www.ti.com/lit/ds/symlink/lm393-n.pdf)

Make sure that the following features are working:
- You can send float values through UART
- You can read the voltage of the R8 potentiometer
- You can measure the RPM of the FAN
- You can set the duty cycle of the PWM signal on the PB3 pin

### Open loop control
Let's use multiple peripherals together. The task is to make an open loop RPM controller.
- Read the ADC value and set a PWM signal according to it. So, if the ADC measures 5V, then set 100% PWM duty cycle. Similarly, if the ADC measures 0V then set 0% PWM duty cycle.
- Print out the PWM duty cycle and the measured PRM of the ventilator to the terminal with UART.

Why this control technique is bad? Our open loop "controller" doesn't care about what RPM is the ventilator turning (if it's turning at all), so it' not really CONTROLS the hole progress, it just sets the PWM and something will happen. No feedback from the ventilator is used.

### Closed loop P control
Let's use feedback from the ventilator. The task is to make a proportional controller, which will regulate the PWM duty cycle according to the measured RPM and the reference
RPM value.

- Use the P controller pseudocode to make your controller
- Try to run the control algorithm periodically
- Play with the P value
- The algorithm run period and the P value determines how will the controller work
    - A good starting value for the period is 10ms
    - A good starting value for the P value is 0.1
- You should print out the duty cycle and the measured RPM to the terminal at least
    - This is useful to check what is going on inside the MCU

Try to apply force to the fan. Ideally, a controller should rise the duty cycle,
and the fan will produce bigger torque to keep the rotational speed constant. The
P controller can't do this exactly. Why?

### Closed loop PI control
The task is to make a proportional ant integrating controller, which will regulate the PWM duty cycle according to the measured RPM and the reference
RPM value.

- Use the P controller pseudocode to make your controller
- Try to run the control algorithm periodically, play with the period value
- Play with the P, I value
- The algorithm run period, the P and the I value determines how will the controller work
    - A good starting value for the period is 10ms
    - A good starting value for the P value is 0.05
    - A good starting value for the I value is 0.01
- You should print out the duty cycle and the measured RPM to the terminal at least
    - This is useful to check what is going on inside the MCU

Try to apply force to the fan again. The PI controller should compensate out the
disturbance and the RPM should remain constant. Of course, if you apply too much force
100% duty cycle will be set and the motor maybe can not produce enough counterforce to
keep the RPM constant. This is not the controller's fault, simply the fan is not
strong enough.

### Advanced tasks:
- Make the P, I values adjustable via UART, play with it

## Solution
