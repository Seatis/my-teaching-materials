# Closed loop control
*Create a program on the MCU which can control the fan speed*

## Objectives
 - Create a bigger project
 - Get familiar with control loops

## Materials & Resources
### Control loops basics
| Material | Duration |
|:---------|-----:|
| [Open-loop System](http://www.electronics-tutorials.ws/systems/open-loop-system.html) | - |
| [Closed-loop Systems](http://www.electronics-tutorials.ws/systems/closed-loop-system.html) | - |

### Advanced Control loops
| Material | Duration |
|:---------|-----:|
| [Proportional control](https://en.wikipedia.org/wiki/Proportional_control) | - |
| [P and PI control](https://www.youtube.com/watch?v=4jgBy1aOltU) | 11:50 |
| [P Only Control](https://www.youtube.com/watch?v=WsUau1GTNF0) | 6:33 |

You can download the excel sheet (which was used in the last video) [here](https://docs.google.com/file/d/0B2Az8mRwS4IacjgyTkUzZEZHdEU/edit). Play with it,
try to understand the different graphs, the settings and what do they do.

### Optional materials
*If you are more interested and don't afraid from a tiny bit of math.*

| Material | Duration |
|:---------|-----:|
| [The PID controller](https://en.wikipedia.org/wiki/PID_controller) | - |

### How to code a P controller
You basically need:
- a reference input, which represents the desired output value
- the controller output, which controls a hardware
- the output signal, which is generated by the hardware

Let's say we have the following variables:

| variable name | functionality |
|:---------|:-----|
| ```ref``` | the reference input |
| ```ctrler_out``` | the output of the controller |
| ```process_variable``` | the output signal of the hardware, which is measured by a sensor |
| ```ctrler_out_min``` | the minimum output of the controller |
| ```ctrler_out_max``` | the maximum output of the controller |
| ```P``` | the P constant |


At first you have to calculate the error from the reference input and from the sensor
value. The next step is to multiply the error with the P constant, than load the result
value to the output. In real life, the output signal has a minimal and maximal value.
We have to limit the output to these levels.

The pseudocode of a P controller would look like:
```c_cpp
err = ref - process_variable;
ctrler_out = P * err;

if (ctrler_out < ctrler_out_min)
    ctrler_out = ctrler_out_min;
else if (ctrler_out > ctrler_out_max)
    ctrler_out = ctrler_out_max;
```

### How to code a PI controller
You basically need:
- a reference input, which represents the desired output value
- the controller output, which controls a hardware
- the output signal, which is generated by the hardware

Let's say we have the following variables:

| variable name | functionality |
|:---------|:-----|
| ```ref``` | the reference input, or setpoint |
| ```ctrler_out``` | the output of the controller |
| ```process_variable``` | the output signal of the hardware, which is measured by a sensor |
| ```ctrler_out_min``` | the minimum output of the controller |
| ```ctrler_out_max``` | the maximum output of the controller |
| ```P``` | the P constant |
| ```I``` | the I constant |


At first you have to calculate the error from the reference input and from the sensor
value. The next step is to calculate the output, which consists of
- the proportional component
- the integral component.

The proportional component is the error multiplied with the P constant.
The integral component is the sum of all previous error multiplied with the I constant.

In real life, the output signal has a minimal and maximal value.
We have to limit the output to these levels.

In case of limiting, the integral part has to be decreased by the error to avoid [integral windup](https://en.wikipedia.org/wiki/Integral_windup).

The pseudocode of a PI controller would look like:
```c_cpp
err = ref - process_variable;
integral = integral + err;
ctrler_out = P * err + I * integral;

if (ctrler_out < ctrler_out_min) {
    ctrler_out = ctrler_out_min;
    integral = integral - err;
}
else if (ctrler_out > ctrler_out_max) {
    ctrler_out = ctrler_out_max;
    integral = integral - err;
}
```

## Workshop
This project is based on the following workshops:
- [PWM](https://github.com/greenfox-academy/teaching-materials/tree/master/workshop/hardware/PWM)
- [AC-peripheral](https://github.com/greenfox-academy/teaching-materials/tree/master/workshop/hardware/AC-peripheral)

This program will be control the fan speed, first with open loop control, at the end of the project with closed loop control.

The input reference voltage will be adjusted with a potentiometer (which is measured with the ADC), the controller output signal will be the duty cycle of the PWM signal (which adjusts the fan rotation speed).
The rotational speed need to be measured, as we did in the AC workshop.

### Basic tasks
- [Make it work](#Make it work)
- [Open loop control](#Open loop control)
- [Closed loop control, P](#Closed loop control, P)
- [Closed loop control, PI](#Closed loop control, PI)

### Advanced
- [Advanced tasks](#Advanced tasks)

### Make it work

<img src="img/connect-all-the-things.jpg" width="25%"></img>

<img src="img/GF-ATmega168PB-controller.png" width="100%"></img>

From the previous workshops copy the necessary driver files and put them together.
Make sure that the following features are working:
- You can send float values through UART
- You can read the voltage of the R8 potentiometer
- You can measure the RPM of the FAN
- You can set the duty cycle of the PWM signal on the PB3 pin

Whit the last one you will probably have a problem. During the PWM workshop we
used the TC0 timer to generate PWM signal on the PD6 pin. This time we could not
use the PD6 pin as the PWM output because the comparator positive input is on that pin.
The solution to that problem is to use the TC2 timer as the PWM signal generator.
Don't be afraid! The TC0 and TC2 timers are very similar, you just have to change
the register and bit names in the TC0 driver to get the TC2 driver.

### Open loop control
Let's use multiple peripherals with each other. It will be an open loop "controller"
- Read the ADC value and set a PWM signal according to it. So, if in the ADC is 5V set 100% PWM duty, if the ADC 0V set 0% PWM duty.
- Print out the PWM duty cycle and the measured PRM of the ventilator.

Why is it bad? Our open loop "controller" doesn't care about what RPM is the ventilator turning, if it's turning, so it' not really CONTROL the hole progress, it just set the PWM and something will happen. No feedback from the ventilator is used.

### Closed loop control, P
Let's use the feedback from the ventilator. It will be a proportional controller, it will regulate the PWM according to the measured RPM.

So:
- Read the ADC value, it will be the setpoint (SP)
- The process variable (PV) will be the measured RPM
- Calculate the error (SP-PV)
- Calculate the output value with the proportional gain (P)

### Closed loop control, PI
 - Use the pseudocode to pimp your controller
 - Play with the P, I values (a lot)

### Advanced tasks:
 - Make the P, I values adjustable via UART, play with it
- Use Atmel studio data visualiser tool to visualise the controlling parameters

## Solution
[Solution](#)
